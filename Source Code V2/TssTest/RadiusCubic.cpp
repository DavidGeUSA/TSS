/*******************************************************************
Author: David Ge (dge893@gmail.com, aka Wei Ge)
Last modified: 11/21/2020
Allrights reserved by David Ge

compare simulation data generated by the Radius Indexing simulator and the Cubic Indexing simulator
********************************************************************/

#include "RadiusCubic.h"
#include "../EMField/FieldSource.h"

RadiusCubic::RadiusCubic()
{
}


RadiusCubic::~RadiusCubic()
{
}

void RadiusCubic::SetFields(Point3Dstruct *ef, Point3Dstruct*hf, FieldPoint3D *ehf, FieldsInitializer *iv, FieldSource *src, double step)
{
	E = ef;
	H = hf;
	EH = ehf;
	fiv = iv;
	fs = src;
	ds = step;
	index = 0;
	maxErr = 0;
}
void RadiusCubic::handleData(int m, int n, int p)
{
	int i = m + maxRadius;
	int j = n + maxRadius;
	int k = p + maxRadius;
	size_t nn = 2 * maxRadius + 1;
	size_t w = k + nn*(j + nn*i);
	//convert data in radius indexing to cubic indexing================
	E[w].x = EH[index].E.x;
	E[w].y = EH[index].E.y;
	E[w].z = EH[index].E.z;
	//
	H[w].x = EH[index].H.x;
	H[w].y = EH[index].H.y;
	H[w].z = EH[index].H.z;
	//================================================================
	//check radius data with its initializer and field source
	if (fiv != NULL && r < maxRadius) //exclude boundary conditions
	{
		Point3Dstruct rd,rdH;
		double x, y, z, err;
		x = ((double)m)*ds;
		y = ((double)n)*ds;
		z = ((double)p)*ds;
		rdH.x = 0; rdH.y = 0; rdH.z = 0;
		//data given by the initializer
		rd.x = fiv->funcE0x(x, y, z);
		rd.y = fiv->funcE0y(x, y, z);
		rd.z = fiv->funcE0z(x, y, z);
		//apply field source
		if (fs != NULL)
		{
			fs->applySourceAtPoint(&rd, &rdH, 0, m, n, p);
		}
		//
		err = abs(rd.x - E[w].x); if (err > maxErr) maxErr = err;
		err = abs(rd.y - E[w].y); if (err > maxErr) maxErr = err;
		err = abs(rd.z - E[w].z); if (err > maxErr) maxErr = err;
	}
	//
	index++;
}