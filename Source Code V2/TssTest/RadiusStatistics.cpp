/*******************************************************************
Author: David Ge (dge893@gmail.com, aka Wei Ge)
Last modified: 11/21/2020
Allrights reserved by David Ge

make field data statistics by radius, the data are generated by the Cubic Indexing simulator
********************************************************************/

#include <stdio.h>
#include "RadiusStatistics.h"
#include "../FileUtil/fileutil.h"

#ifdef __linux__ 
#include <cstring>
#endif

FILE *fhReport = 0;
void writeRadiusStatistics(const char *message, bool sameline)
{
	if (!sameline)
	{
		writefile(fhReport, "\r\n", 2);
	}
	writefile(fhReport, message, (int)strlen(message));
}

RadiusStatistics::RadiusStatistics()
{
	efile = NULL;
	hfile = NULL;
}


RadiusStatistics::~RadiusStatistics()
{
}

int RadiusStatistics::initialize(Point3Dstruct *fE, Point3Dstruct *fH, unsigned int maxR, Simulator *tsssim)
{
	int ret = ERR_OK;
	efile = fE;
	hfile = fH;
	sim = tsssim;
	fs.Reset();
	ret = fs.AllocateList(maxR);
	nx1 = 2 * maxR + 1; ny1 = nx1; nz1 = nx1;
	return ret;
}
inline size_t RadiusStatistics::Idx(unsigned i, unsigned j, unsigned k)
{
	return k + nz1 * (j + ny1 * i);
}
RadiusHandleType RadiusStatistics::setRadius(int radius)
{
	return GoThroughSphereByIndexes::setRadius(radius);
}
void RadiusStatistics::handleData(int m, int n, int p)
{
	int i = m + maxRadius;
	int j = n + maxRadius;
	int k = p + maxRadius;
	double dgE = abs(sim->dx_Fx(efile, 1, i, j, k) + sim->dy_Fy(efile, 1, i, j, k) + sim->dz_Fz(efile, 1, i, j, k));
	double dgH = abs(sim->dx_Fx(hfile, 1, i, j, k) + sim->dy_Fy(hfile, 1, i, j, k) + sim->dz_Fz(hfile, 1, i, j, k));
	//Size3Dstruct *ic = sim->GetIndexCache();
	size_t w = Idx(i,j,k);
	double emag = efile[w].x * efile[w].x + efile[w].y * efile[w].y + efile[w].z * efile[w].z;
	double hmag = hfile[w].x * hfile[w].x + hfile[w].y * hfile[w].y + hfile[w].z * hfile[w].z;
	TssSimStruct * simObj = sim->GetSimParameters();
	double x = m*simObj->pams.ds;
	double y = n*simObj->pams.ds;
	double z = p*simObj->pams.ds;
	DivergenceByRadius *list = fs.GetList();
	double energy = simObj->pams.eps*(emag) / 2.0 + simObj->pams.mu*(hmag) / 2.0;
	//Poynting vector = S = E X H
	double sx = efile[w].y * hfile[w].z - hfile[w].y * efile[w].z;
	double sy = efile[w].z * hfile[w].x - hfile[w].z * efile[w].x;
	double sz = efile[w].x * hfile[w].y - hfile[w].x * efile[w].y;
	//
	double sm = sqrt(sx * sx + sy * sy + sz * sz); //||S||
	double sa = x * sx + y * sy + z * sz;          // (x, y, z) dot S
	//use energy level to set a magnitude threhold for determining orthogonal energy
	double se = energy;
	if (se > 1.0)
		se = 1.0e-8;
	else
		se = 1.0e-8 * se;
	//Energy point is at (x,y,z), as if (x,y,z) is the original point, the direction of vector (x,y,z) is from (x,y,z) to (0,0,0)
	if (sa > se) //(x, y, z) dot S > 0, S is in the same direction of (x,y,z) -> (0,0,0)
	{
		list[r].sumEnergyInwards += sm; //energy goes towards (0,0,0)
	}
	else if (sa < -se) //(x, y, z) dot S < 0, S is in the opposit direction of (x,y,z) -> (0,0,0)
	{
		list[r].sumEnergyOutwards += sm; //energy goes away from (0,0,0)
	}
	else //S is orthogonal to (x,y,z) -> (0,0,0)
	{
		list[r].sumEnergyCircular += sm; ////energy goes circling around (0,0,0)
	}

	///////////////////////////////////////////////////
	dgE = dgE / simObj->pams.ds;
	//if (emag > 0.00001)
	//{
	//	dgE = dgE / emag;
	//}
	dgH = dgH / simObj->pams.ds;
	//if (hmag > 0.00001)
	//{
	//	dgH = dgH / hmag;
	//}
	fs.SetDivergences(dgE, dgH);
	fs.MakeStatistics(emag, hmag, energy, r);
	//
	index++;
}

int RadiusStatistics::writeStatisticsToFile(FILE *filehandle)
{
	fhReport = filehandle;
	fs.ShowSummary(writeRadiusStatistics);
	fs.ShowReport(writeRadiusStatistics);
	return ERR_OK;
}